import * as tf from "@tensorflow/tfjs-node";
import { ModelMetadata } from "./loader";

/**
 * Peforms pad sequencing so that all sentences have the exact same length before prediction
 * @param {*} sequences List of word values generated by matching sentences with model metadata
 * @param {*} maxLen Maximum length of sequence
 * @param {*} padding Padding mode i.e. pre or post
 * @param {*} truncating Trauncating mode i.e. pre or post
 * @param {*} value Value to pad with
 * @tutorial https://keras.io/api/preprocessing/timeseries/
 */
const pad = (
  sequences: number[][],
  maxLen: number,
  padding: "pre" | "post" = "pre",
  truncating: "pre" | "post" = "pre",
  value: number = 0
) => {
  return sequences.map((seq) => {
    // truncating
    if (seq.length > maxLen) {
      if (truncating === "pre") {
        seq.splice(0, seq.length - maxLen);
      } else {
        seq.splice(maxLen, seq.length - maxLen);
      }
    }

    // padding
    if (seq.length < maxLen) {
      const padded = [];
      for (let i = 0; i < maxLen - seq.length; i++) {
        padded.push(value);
      }
      if (padding === "pre") {
        seq = padded.concat(seq);
      } else {
        seq = seq.concat(padded);
      }
    }
    return seq;
  });
};

export const predict = async (
  sentence: string,
  model: tf.LayersModel,
  { wordIndex, indexFrom, vocabularySize, maxLen }: ModelMetadata
) => {
  // console.log(sentence);
  // remove punctuation and split get individual words
  const inputText = sentence
    .trim()
    .toLowerCase()
    .replace(/(\.|\,|\!)/g, "")
    .split(" ");
  // console.log(inputText);
  // matches words with metadata value
  const excluded: string[] = [];
  const sequence = inputText
    .map((word) => {
      let wordIdx = wordIndex[word] + indexFrom;

      if (Number.isNaN(wordIdx)) {
        excluded.push(word);
        return;
      }
      if (wordIdx > vocabularySize) {
        wordIdx = 2;
      }
      return wordIdx;
    })
    .filter((s) => !!s) as number[];

  // console.log(sequence, excluded);

  // padding
  const paddedSequence = pad([sequence], maxLen);

  // creates 2d tensor (2D matrix) with consistent length
  const input = tf.tensor2d(paddedSequence, [1, maxLen]);

  const prediction = model.predict(input) as tf.Tensor<tf.Rank>;
  const score = prediction.dataSync()[0];
  prediction.dispose();

  const sentiment = score > 0.65 ? "Positive" : "Negative";

  return { sentence, score, sentiment, excluded };
};
